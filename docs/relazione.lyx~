#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrartcl
\use_default_options true
\maintain_unincluded_children no
\language italian
\language_package auto
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\topmargin 1.5cm
\rightmargin 1.5cm
\bottommargin 2.5cm
\headheight 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Progetto 
\begin_inset Quotes eld
\end_inset

Battleship AI
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subtitle
Relazione per il progetto del Corso di PMO
\end_layout

\begin_layout Author
Papadopol Lucian-Ioan
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename esempio_gioco.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
ANALISI
\end_layout

\begin_layout Subsection
REQUISITI
\end_layout

\begin_layout Standard
L’obiettivo dell’applicazione è creare un videogioco che implementi il gioco Battaglia Navale.
\end_layout

\begin_layout Standard
Il giocatore deve avere come avversario un’intelligenza artificiale basilare pseudo-AI;
 il gioco deve rispettare delle regole specifiche che si discostano leggermente da quelle classiche garantendo anche un’esperienza chiara e coinvolgente per l’utente.
\end_layout

\begin_layout Subsubsection
Requisiti Funzionali
\end_layout

\begin_layout Standard
L’applicazione dovrà consentire ai giocatori di:
\end_layout

\begin_layout Itemize
Avviare una nuova partita.
\end_layout

\begin_layout Itemize
Selezionare il livello di difficoltà dell’IA.
\end_layout

\begin_layout Itemize
Posizionare le proprie navi su una griglia,
 rispettando le regole del gioco:
\end_layout

\begin_deeper
\begin_layout Itemize
Le navi non devono sovrapporsi.
\end_layout

\begin_layout Itemize
Devono essere posizionate interamente dentro la griglia.
\end_layout

\begin_layout Itemize
Possono avere orientamento orizzontale o verticale.
\end_layout

\end_deeper
\begin_layout Itemize
Effettuare attacchi sulla griglia avversaria scegliendo le coordinate del colpo.
\end_layout

\begin_layout Itemize
Utilizzare diverse tipologie di proiettili,
 con effetti differenti sul gioco.
\end_layout

\begin_layout Itemize
Visualizzare lo stato della griglia,
 distinguendo:
\end_layout

\begin_deeper
\begin_layout Itemize
Le proprie navi e gli attacchi subiti.
\end_layout

\begin_layout Itemize
Gli attacchi effettuati contro l’avversario.
\end_layout

\end_deeper
\begin_layout Itemize
Gestire la fine della partita,
 determinando il vincitore quando tutte le navi di un giocatore sono affondate.
\end_layout

\begin_layout Itemize
Mostrare messaggi informativi e di gioco,
 per guidare il giocatore durante la partita.
\end_layout

\begin_layout Subsubsection
Requisiti Non Funzionali
\end_layout

\begin_layout Standard
Oltre alle funzionalità principali,
 l’applicazione dovrà:
\end_layout

\begin_layout Itemize
Essere accessibile e di facile uso per l'utente.
\end_layout

\begin_layout Itemize
Garantire tempi di risposta rapidi per una fluida esperienza di gioco.
\end_layout

\begin_layout Itemize
Fornire un’interfaccia chiara e leggibile,
 con feedback sugli eventi di gioco.
\end_layout

\begin_layout Itemize
Offrire un’esperienza equa e bilanciata,
 assicurando che l’IA non sia né troppo prevedibile né imbattibile.
\end_layout

\begin_layout Itemize
Essere estensibile,
 permettendo future modifiche o aggiunte di nuove modalità di gioco.
\end_layout

\begin_layout Itemize
Non richiedere connessione a Internet,
 essendo pensata per il gioco in locale.
\end_layout

\begin_layout Subsubsection
Diagramma dei casi d'uso
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename diagramma_casi_uso
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagramma dei casi d'uso
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il diagramma dei casi d’uso rappresenta le principali interazioni tra il giocatore e il sistema di gioco Battaglia Navale.
\end_layout

\begin_layout Itemize

\series bold
Attori Coinvolti
\end_layout

\begin_deeper
\begin_layout Itemize

\shape italic
Giocatore.

\shape default
 L'utente umano che interagisce con l’applicazione.
\end_layout

\begin_layout Itemize

\shape italic
IA.
 
\shape default
L’intelligenza artificiale che funge da avversario automatico.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Casi d’Uso Principali
\end_layout

\begin_deeper
\begin_layout Itemize

\shape italic
Avvia partita.

\shape default
 Il giocatore inizia una nuova partita.
\end_layout

\begin_layout Itemize

\shape italic
Seleziona difficoltà IA.

\shape default
 Il giocatore sceglie il livello di sfida dell’intelligenza artificiale.
\end_layout

\begin_layout Itemize

\shape italic
Posiziona le navi.

\shape default
 Il giocatore e l’IA dispongono le proprie navi sulla griglia,
 rispettando le regole di posizionamento.
\end_layout

\begin_layout Itemize

\shape italic
Effettua un attacco.

\shape default
 Durante il proprio turno,
 il giocatore o l’IA scelgono una casella sulla griglia avversaria per tentare di colpire una nave nemica.
\end_layout

\begin_layout Itemize

\shape italic
Sceglie tipo di proiettile.

\shape default
 Il giocatore può decidere quale proiettile utilizzare tra le opzioni disponibili.
\end_layout

\begin_layout Itemize

\shape italic
Visualizza stato della griglia.

\shape default
 Il giocatore può controllare la propria griglia e quella d’attacco per analizzare l’andamento della partita.
\end_layout

\begin_layout Itemize

\shape italic
Riceve messaggi di gioco.
 
\shape default
Il sistema fornisce notifiche sullo stato della partita (es.
 colpi andati a segno,
 navi affondate).
\end_layout

\begin_layout Itemize

\shape italic
Termina partita.

\shape default
 Il gioco rileva automaticamente il vincitore quando tutte le navi di un giocatore sono affondate.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Relazioni tra Attori e Casi d’Uso
\end_layout

\begin_deeper
\begin_layout Itemize
Il Giocatore interagisce con tutte le funzionalità del sistema,
 poiché prende decisioni attive durante la partita.
\end_layout

\begin_layout Itemize
L'IA è responsabile solo di due azioni:
\end_layout

\begin_deeper
\begin_layout Enumerate
Posizionare le proprie navi in modo automatico.
\end_layout

\begin_layout Enumerate
Effettuare attacchi contro il giocatore,
 secondo una logica variabile in base al livello di difficoltà selezionato.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
MODELLO DEL DOMINIO
\end_layout

\begin_layout Subsubsection
Descrizione del dominio
\end_layout

\begin_layout Standard
L’applicazione Battaglia Navale si svolge in un campo di gioco diviso in due griglie:
\end_layout

\begin_layout Enumerate

\shape italic
La griglia personale
\shape default
,
 dove il giocatore posiziona le proprie navi e vengono indicati i colpi ricevuti oltre al livello di danno subito per ogni nave.
\end_layout

\begin_layout Enumerate

\shape italic
La griglia d’attacco
\shape default
,
 dove vengono registrati i colpi sparati contro l’avversario.
\end_layout

\begin_layout Standard
Le navi vengono posizionate all’inizio del gioco e devono rispettare regole specifiche:
 non sovrapporsi,
 essere posizionate interamente nella griglia.
 
\end_layout

\begin_layout Standard
Durante il gioco,
 il giocatore e l’IA si alternano per effettuare attacchi,
 cercando di affondare le navi avversarie.
 Un colpo può colpire una nave o finire in acqua.
\end_layout

\begin_layout Standard
Ogni nave è composta da caselle della griglia,
 e ogni casella può avere diversi stati:
\end_layout

\begin_layout Itemize
Vuota e non colpita (acqua).
\end_layout

\begin_layout Itemize
Vuota,
 colpita ma senza danno (acqua).
\end_layout

\begin_layout Itemize
Occupata da una nave e non colpita.
\end_layout

\begin_layout Itemize
Occupata da una nave,
 colpita e con associato danno progressivo.
\end_layout

\begin_layout Itemize
Affondata,
 se tutte le caselle di una nave sono colpite.
\end_layout

\begin_layout Standard
Esistono diverse tipologie di proiettili,
 che possono infliggere più o meno danni a una casella.
\end_layout

\begin_layout Standard
Il gioco termina quando tutte le navi di un giocatore sono affondate.
\end_layout

\begin_layout Subsubsection
Identificazione delle Entità
\end_layout

\begin_layout Standard
Analizzando il problema,
 emergono le seguenti entità principali:
\end_layout

\begin_layout Itemize

\series bold
Giocatore
\series default
.
 Partecipa alla partita e possiede una griglia.
\end_layout

\begin_layout Itemize

\series bold
IA
\series default
.
 Gioca contro il giocatore con una strategia variabile.
\end_layout

\begin_layout Itemize

\series bold
Griglia
\series default
.
 Campo di gioco su cui vengono posizionate le navi e registrati i colpi.
\end_layout

\begin_layout Itemize

\series bold
Casella
\series default
.
 Unità base della griglia,
 può contenere o meno una parte di una nave.
\end_layout

\begin_layout Itemize

\series bold
Nave
\series default
.
 Composta da più caselle,
 può essere colpita e affondata.
\end_layout

\begin_layout Itemize

\series bold
Proiettile
\series default
.
 Può avere effetti diversi sulla griglia (normale,
 potente,
 speciale).
\end_layout

\begin_layout Itemize

\series bold
Partita
\series default
.
 Gestisce il flusso di gioco e le condizioni di vittoria.
\end_layout

\begin_layout Subsubsection
Relazioni tra le entità
\end_layout

\begin_layout Enumerate
Un giocatore 
\shape italic
possiede
\shape default
 una griglia su cui posiziona le proprie navi.
\end_layout

\begin_layout Enumerate
Una griglia è 
\shape italic
composta
\shape default
 da caselle che possono essere vuote o occupate da una nave.
\end_layout

\begin_layout Enumerate
Una nave è 
\shape italic
composta
\shape default
 da più caselle e può essere affondata.
\end_layout

\begin_layout Enumerate
Un giocatore o l’IA possono sparare un proiettile,
 che colpisce una casella della griglia avversaria.
\end_layout

\begin_layout Enumerate
La partita coordina i turni e determina la vittoria.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Entità
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Descrizione
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Relazione con altre entità
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Partita
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rappresenta l’intero flusso del gioco
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Controlla le griglie dei giocatori
\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Gestisce i turni tra il giocatore e l'IA
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Griglia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Campo di gioco del giocatore
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
È composta da più caselle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Casella
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Singola unità della griglia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Può contenere una nave
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Nave
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unità da affondare
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
È composta da più caselle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Proiettile
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Oggetto che infligge danno in un attacco
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Colpisce una casella
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Riepilogo entità principali e loro relazioni
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Schema UML del dominio
\end_layout

\begin_layout Standard
Questo schema è una rappresentazione concettuale che descrive le entità principali del dominio applicativo e le loro relazioni.
 
\end_layout

\begin_layout Standard
Serve a comprendere e modellare il problema prima di iniziare l'implementazione del software.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename UML_dominio.png
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schema ULM del dominio
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
DESIGN
\end_layout

\begin_layout Subsection
ARCHITETTURA
\end_layout

\begin_layout Standard
L’architettura dell’applicazione Battleship-AI è progettata seguendo il pattern Model-View-Controller (MVC),
 un design pattern che permette di separare la logica di business (Model),
 la gestione dell’interfaccia utente (View) e il controllo del flusso dell’applicazione (Controller).
\end_layout

\begin_layout Standard
L'uso di MVC permette di mantenere il codice modulare,
 facilitando la manutenzione,
 l'estensibilità e la possibilità di sostituire le interfacce utente (passaggio tra GUI e TUI) senza modificare il modello o il controller.
\end_layout

\begin_layout Subsubsection
Panoramica dell'architettura MVC
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename mvc_gen.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
MVC design pattern
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L’architettura si suddivide in tre componenti principali:
\begin_inset Newline newline
\end_inset


\series bold
Model
\end_layout

\begin_layout Itemize
Definisce la logica di gioco e le regole.
\end_layout

\begin_layout Itemize
Contiene le classi che gestiscono griglie,
 navi,
 caselle,
 proiettili e logica di battaglia.
\end_layout

\begin_layout Itemize
Non conosce né interagisce direttamente con la View.
\end_layout

\begin_layout Standard

\series bold
View
\end_layout

\begin_layout Itemize
Si occupa della rappresentazione dell'interfaccia utente.
\end_layout

\begin_layout Itemize
Può essere implementata in modalità grafica (GUI) o testuale (TUI).
\end_layout

\begin_layout Itemize
Riceve aggiornamenti dallo stato del Model e li mostra all'utente.
\end_layout

\begin_layout Standard

\series bold
Controller
\end_layout

\begin_layout Itemize
Gestisce il flusso di gioco e l'interazione tra Model e View.
\end_layout

\begin_layout Itemize
Contiene la logica di gestione dei turni,
 attacchi,
 scelta dei proiettili e gestione dell'IA.
\end_layout

\begin_layout Itemize
Non implementa logica di gioco,
 ma chiama il Model per eseguire azioni e aggiorna la View di conseguenza.
\end_layout

\begin_layout Subsubsection
Ruoli e Interazione tra i Componenti
\end_layout

\begin_layout Minisec
Model
\end_layout

\begin_layout Standard
Ruoli principali:
\end_layout

\begin_layout Itemize
Gestisce la logica di gioco,
 comprese le regole e lo stato della partita.
\end_layout

\begin_layout Itemize
Contiene e aggiorna i dati relativi alla griglia,
 alle navi e ai colpi sparati.
\end_layout

\begin_layout Itemize
Fornisce informazioni sullo stato del gioco (es.
 chi ha vinto,
 quali navi sono affondate).
\end_layout

\begin_layout Standard
Interazione con gli altri componenti:
\end_layout

\begin_layout Itemize
Riceve comandi dal Controller per aggiornare lo stato della partita (es.
 eseguire un turno,
 applicare danni a una nave).
\end_layout

\begin_layout Itemize
Restituisce informazioni al Controller,
 come il risultato di un attacco o lo stato del gioco.
\end_layout

\begin_layout Minisec
View
\end_layout

\begin_layout Standard
Ruoli principali:
\end_layout

\begin_layout Itemize
Mostra all'utente lo stato della partita (interfaccia testuale o grafica).
\end_layout

\begin_layout Itemize
Riceve input dal giocatore e lo inoltra al Controller.
\end_layout

\begin_layout Itemize
Aggiorna la visualizzazione in base agli eventi di gioco.
\end_layout

\begin_layout Standard
Interazione con gli altri componenti:
\end_layout

\begin_layout Itemize
Riceve dati dal Controller per aggiornare l'interfaccia utente.
\end_layout

\begin_layout Itemize
Invia input utente al Controller,
 che poi decide le azioni da eseguire.
\end_layout

\begin_layout Minisec
Controller
\end_layout

\begin_layout Standard
Ruoli principali:
\end_layout

\begin_layout Itemize
Coordina il flusso di gioco,
 decidendo quando e come aggiornare il Model o la View.
\end_layout

\begin_layout Itemize
Gestisce la logica dell’intelligenza artificiale.
\end_layout

\begin_layout Itemize
Garantisce la separazione tra Model e View,
 agendo come mediatore.
\end_layout

\begin_layout Standard
Interazione con gli altri componenti:
\end_layout

\begin_layout Itemize
Riceve input dalla View e lo traduce in comandi per il Model.
\end_layout

\begin_layout Itemize
Interroga il Model per ottenere lo stato della partita.
\end_layout

\begin_layout Itemize
Aggiorna la View in base ai cambiamenti avvenuti nel Model.
\end_layout

\begin_layout Subsubsection
Identificazione delle Classi Chiave
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename mvc.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Interfacce del MVC
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Minisec
Model
\end_layout

\begin_layout Standard
Punto di ingresso:
 
\shape italic
ModelInterface.java
\shape default
 Definisce l’insieme di operazioni eseguibili sulla logica di gioco e permette al Controller di interagire con il Model senza dipendere dall’implementazione concreta.
 
\begin_inset Newline newline
\end_inset

Classi che implementano il Model:
\end_layout

\begin_layout Itemize

\shape italic
Battle.java
\shape default
 Contiene la logica della partita e implementa ModelInterface.
\end_layout

\begin_layout Minisec
View
\end_layout

\begin_layout Standard
Punto di ingresso:
 
\shape italic
ViewInterface.java
\shape default
 Definisce un'interfaccia comune per la gestione dell'interfaccia utente.
 Consente di gestire sia l’interfaccia testuale (TUI) che quella grafica (GUI) senza modificare il Controller.
 
\begin_inset Newline newline
\end_inset

Classi che implementano la View:
\end_layout

\begin_layout Itemize

\shape italic
Gui.java
\shape default
 Implementa ViewInterface,
 fornendo un’interfaccia grafica.
\end_layout

\begin_layout Itemize

\shape italic
Tui.java
\shape default
 Implementa ViewInterface,
 fornendo un’interfaccia testuale.
\end_layout

\begin_layout Minisec
Controller
\end_layout

\begin_layout Standard
Punto di ingresso:
 
\shape italic
ControllerInterface.java
\shape default
 Definisce i metodi fondamentali per la gestione della partita e il posizionamento delle navi.
 Separa la logica del gioco dalla gestione dell’interfaccia.
 
\begin_inset Newline newline
\end_inset

Classi che implementano il Controller:
\end_layout

\begin_layout Itemize

\shape italic
GameController.java
\shape default
 Implementa ControllerInterface,
 gestisce l’interazione tra Model e View.
\end_layout

\begin_layout Subsection
DESIGN DETTAGLIATO
\end_layout

\begin_layout Subsubsection
Gestione flessibile dei proiettili con il design pattern Factory Method
\end_layout

\begin_layout Standard

\series bold
Il problema
\series default
 
\begin_inset Newline newline
\end_inset

Nel gioco della battaglia navale,
 ogni turno prevede la scelta e l’uso di un proiettile da parte del giocatore o dell’IA.
 
\begin_inset Newline newline
\end_inset

Sono disponibili più tipi di proiettili (standard,
 potente,
 speciale),
 ognuno con caratteristiche differenti.
 
\begin_inset Newline newline
\end_inset

Il problema nasce nel momento in cui la logica di creazione dei proiettili viene ripetuta o dispersa nel codice,
 portando a duplicazioni,
 mancanza di coerenza e difficoltà di manutenzione.
\series bold

\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

La soluzione
\begin_inset Newline newline
\end_inset


\series default
Per risolvere questo problema si è adottato il 
\series bold
Factory Method
\series default
,
 che consente di incapsulare la logica di creazione dei proiettili all’interno di una classe dedicata 
\shape italic
ProjectileHandler
\shape default
,
 restituendo un oggetto polimorfico di tipo Projectile.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Alternative considerate
\end_layout

\begin_layout Itemize
Creazione diretta nei controller
\end_layout

\begin_deeper
\begin_layout Itemize
Pro:
 semplice da scrivere
\end_layout

\begin_layout Itemize
Contro:
 ripetitivo,
 difficile da manutenere,
 rende difficile introdurre nuovi tipi di proiettile
\end_layout

\end_deeper
\begin_layout Standard

\series bold
Implementazione
\series default

\begin_inset Newline newline
\end_inset

Classi coinvolte
\end_layout

\begin_layout Itemize

\shape italic
Projectile.java
\shape default
 classe astratta che rappresenta un generico proiettile.
\end_layout

\begin_layout Itemize

\shape italic
StandardProjectile.java
\shape default
,
 
\shape italic
PowerProjectile.java
\shape default
,
 
\shape italic
SpecialProjectile.java
\shape default
 sottoclassi concrete di Projectile.
\end_layout

\begin_layout Itemize

\shape slanted
ProjectileHandler.java
\shape default
 classe che contiene il 
\bar under
metodo factory
\bar default
 
\shape italic
makeProjectile(int type,
 Player player).
\end_layout

\begin_layout Standard
Relazioni
\end_layout

\begin_layout Itemize
Il controller,
 sia umano che IA,
 chiama ProjectileHandler.makeProjectile() per creare un proiettile.
\end_layout

\begin_layout Itemize
ProjectileHandler crea il tipo di proiettile richiesto e restituisce l'oggetto di tipo Projectile corrispondente;
 
\begin_inset Newline newline
\end_inset

il metodo può adattarsi alla disponibilità del giocatore,
 ad esempio se ha ancora proiettili speciali e decidere dinamicamente il tipo di proiettile da creare.
\end_layout

\begin_layout Itemize
Il chiamante non conosce la classe concreta:
 utilizza l’oggetto restituito in modo polimorfico.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename UML_factory.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementazione del design pattern Factory
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Gestione flessibile delle strategie di attacco dell’IA con il design pattern Strategy
\end_layout

\begin_layout Standard

\series bold
Il problema
\series default

\begin_inset Newline newline
\end_inset

Nel gioco della Battaglia Navale,
 il comportamento dell’IA durante il proprio turno varia in base al livello di difficoltà scelto dal giocatore (facile,
 medio,
 difficile).
\begin_inset Newline newline
\end_inset

Inizialmente,
 tutta la logica delle diverse modalità era inserita direttamente nella classe PcTurnHandler,
 tramite una struttura switch-case che selezionava tra i metodi playEasy(),
 playMedium() e playHard().
\begin_inset Newline newline
\end_inset

Questo approccio presentava alcuni problemi:
\end_layout

\begin_layout Itemize
Il codice diventava difficile da leggere e mantenere,
 a causa della crescita della complessità interna.
\end_layout

\begin_layout Itemize
Aggiungere nuove strategie richiedeva modificare la classe PcTurnHandler.
\end_layout

\begin_layout Itemize
Il comportamento dell’IA era rigidamente accoppiato a una singola classe.
\end_layout

\begin_layout Standard

\series bold
La soluzione
\series default

\begin_inset Newline newline
\end_inset

Per risolvere questi problemi è stato adottato il Strategy Pattern,
 un pattern comportamentale che permette di incapsulare algoritmi alternativi (strategie) all’interno di classi distinte,
 intercambiabili a runtime.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Struttura della soluzione
\end_layout

\begin_layout Itemize
È stata introdotta un’interfaccia AITurnStrategy,
 che rappresenta una generica strategia di attacco dell’IA.
\end_layout

\begin_layout Itemize
Ogni strategia concreta (EasyStrategy,
 MediumStrategy,
 HardStrategy) implementa questa interfaccia e incapsula il proprio algoritmo.
\end_layout

\begin_layout Itemize
La classe PcTurnHandler seleziona la strategia in fase di costruzione,
 in base al livello di difficoltà scelto,
 e la usa senza conoscerne i dettagli.
\end_layout

\begin_layout Standard
Alternative considerate
\end_layout

\begin_layout Itemize
Switch-case centralizzato in PcTurnHandler:
\end_layout

\begin_deeper
\begin_layout Itemize
Pro:
 semplice da implementare
\end_layout

\begin_layout Itemize
Contro:
 codice poco leggibile,
 difficile da estendere
\end_layout

\end_deeper
\begin_layout Standard

\series bold
Implementazione
\series default

\begin_inset Newline newline
\end_inset

Classi coinvolte
\end_layout

\begin_layout Itemize

\shape italic
AITurnStrategy.java
\shape default
 interfaccia che definisce il metodo executeTurn(Player currentPlayer).
\end_layout

\begin_layout Itemize

\shape italic
EasyStrategy.java
\shape default
,
 
\shape italic
MediumStrategy.java
\shape default
,
 
\shape italic
HardStrategy.java
\shape default
 → classi concrete che implementano AITurnStrategy,
 ognuna con una strategia di attacco diversa.
\end_layout

\begin_layout Itemize

\shape italic
PcTurnHandler.java
\shape default
 seleziona la strategia in base alla difficoltà e la utilizza per eseguire il turno del PC.
\end_layout

\begin_layout Standard
Relazioni
\end_layout

\begin_layout Itemize
PcTurnHandler dipende dall'interfaccia AITurnStrategy,
 non dalle implementazioni specifiche.
\end_layout

\begin_layout Itemize
Ogni strategia può utilizzare ModelInterface,
 ViewInterface e ProjectileHandler per eseguire il comportamento specifico.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename UML_strategy.png
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Design pattern Strategy
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Gestione del livello di difficoltà dell’intelligenza artificiale
\end_layout

\begin_layout Standard

\series bold
Il problema
\series default

\begin_inset Newline newline
\end_inset

Nel contesto del gioco della Battaglia Navale,
 il giocatore umano si confronta con un avversario gestito dall’intelligenza artificiale (IA).
 
\begin_inset Newline newline
\end_inset

Tuttavia,
 un'IA che gioca sempre nello stesso modo ad esempio tirando a caso,
 rischia di risultare troppo prevedibile e noiosa per un utente esperto,
 oppure troppo difficile se gioca sempre in modo ottimizzato.
\begin_inset Newline newline
\end_inset

Il problema risiede quindi nella necessità di offrire un'esperienza di gioco equilibrata e personalizzabile,
 capace di adattarsi al livello del giocatore.
\begin_inset Newline newline
\end_inset

In particolare,
 si volevano soddisfare i seguenti requisiti:
\end_layout

\begin_layout Itemize
Offrire una sfida più accessibile ai principianti.
\end_layout

\begin_layout Itemize
Consentire una partita più stimolante per giocatori esperti.
\end_layout

\begin_layout Itemize
Evitare che l’IA si comporti in modo completamente casuale o totalmente invincibile in tutte le situazioni.
\end_layout

\begin_layout Standard

\series bold
La soluzione
\begin_inset Newline newline
\end_inset


\series default
Per risolvere il problema si è deciso di introdurre tre livelli di difficoltà per l’IA,
 ognuno con un comportamento di attacco differente:
\end_layout

\begin_layout Itemize
Livello 1 facile:
 l’IA sceglie casualmente una cella da colpire.
\end_layout

\begin_layout Itemize
Livello 2 medio:
 l’IA utilizza una strategia “hunt and target”:
 se colpisce una nave,
 cerca di colpire le celle adiacenti.
\end_layout

\begin_layout Itemize
Livello 3 difficile:
 l’IA usa un approccio pseudo-intelligente,
 analizzando la griglia per stimare la probabilità che una cella contenga una nave,
 e colpendo di conseguenza.
\end_layout

\begin_layout Standard
Alternative considerate
\end_layout

\begin_layout Itemize
IA unica con comportamento fisso:
\end_layout

\begin_deeper
\begin_layout Itemize
Pro:
 implementazione più semplice.
\end_layout

\begin_layout Itemize
Contro:
 esperienza di gioco statica,
 poco scalabile,
 adatta solo a un certo tipo di giocatore.
\end_layout

\end_deeper
\begin_layout Standard

\series bold
Considerazioni sulla scelta
\series default

\begin_inset Newline newline
\end_inset

La soluzione scelta ha il vantaggio di:
\end_layout

\begin_layout Itemize
Rendere il gioco accessibile a tutti,
 dai principianti agli utenti esperti.
\end_layout

\begin_layout Itemize
Migliorare la longevità del gioco,
 permettendo di ripetere le partite con livelli di sfida differenti.
\end_layout

\begin_layout Itemize
Facilitare la manutenzione e l’espandibilità,
 grazie all'uso del pattern Strategy che incapsula ogni comportamento in una classe separata.
\end_layout

\begin_layout Standard

\series bold
Implementazione
\series default

\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Modalità Facile – Tiro completamente casuale
\end_layout

\begin_layout Itemize
L’IA sceglie casualmente una cella della griglia del giocatore,
 senza tenere conto di colpi precedenti o della disposizione delle navi.
\end_layout

\begin_layout Itemize
Anche la scelta del tipo di proiettile è casuale.
\end_layout

\begin_layout Itemize
Non viene applicata alcuna logica predittiva o di ricerca.
\end_layout

\begin_layout Itemize
Obiettivo:
 simulare un comportamento semplice,
 simile a un principiante,
 rendendo la sfida molto accessibile.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename livelloEasy.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart algoritmo di attacco casuale - livello semplice
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Modalità Media – “Hunt and Target”
\end_layout

\begin_layout Itemize
L’IA effettua un tiro casuale finché non colpisce una nave (modalità “hunt”).
\end_layout

\begin_layout Itemize
Una volta ottenuto un colpo a segno,
 memorizza la posizione e inizia a colpire le celle adiacenti (modalità “target”),
 nel tentativo di affondare la nave.
\end_layout

\begin_layout Itemize
Usa anche un proiettile più potente se individua una nave non ancora completamente danneggiata.
\end_layout

\begin_layout Itemize
Obiettivo:
 simulare un giocatore più attento,
 in grado di ragionare in modo elementare sulla disposizione delle navi.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename livelloMedium.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart algoritmo di attacco ottimizzato - livello medio
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Modalità Difficile – Pseudo-AI con valutazione probabilistica
\end_layout

\begin_layout Itemize
L’IA analizza l’intera griglia nemica e assegna un punteggio a ciascuna cella in base alla probabilità che contenga parte di una nave.
\end_layout

\begin_layout Itemize
Se trova celle già colpite ma non affondate,
 passa in modalità “target” intelligente e colpisce le celle più promettenti attorno al bersaglio.
\end_layout

\begin_layout Itemize
La scelta del tipo di proiettile è ottimizzata in base alla probabilità stimata di successo.
\end_layout

\begin_layout Itemize
L'approccio adottato trae ispirazione dai primi sistemi esperti,
 che spesso combinavano regole decisionali con valutazioni probabilistiche per gestire l'incertezza e migliorare l'efficacia delle decisioni.
\end_layout

\begin_layout Itemize
Obiettivo:
 simulare un comportamento “intelligente”,
 che anticipa le mosse del giocatore e aumenta significativamente la difficoltà.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
alignment document
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename livelloHard.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flowchart algoritmo di attacco pseudo-IA - livello difficile
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
SVILUPPO
\end_layout

\begin_layout Subsection
TESTING AUTOMATIZZATO
\end_layout

\begin_layout Standard
Il testing automatizzato è stato implementato nel package 
\series bold
test
\series default
.
 
\begin_inset Newline newline
\end_inset

Ho scelto di testare 
\begin_inset Quotes eld
\end_inset

il core
\begin_inset Quotes erd
\end_inset

 della logica di gioco ovvero l'insieme delle entità e delle regole cui il buon funzionamento impatta maggiormente sulla funzionalità complessiva dell'applicazione.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Vi sono quattro test JUnit:
\end_layout

\begin_layout Enumerate

\series bold
GridSquareTest.java
\series default
 Testa il comportamento della classe 
\shape italic
GridSquare.java
\shape default
,
 che rappresenta una singola casella della griglia.
\end_layout

\begin_deeper
\begin_layout Enumerate

\shape italic
gridSquareCreationTest()
\shape default
 Verifica che una casella venga creata correttamente con coordinate e valori di default.
\end_layout

\begin_layout Enumerate

\shape italic
customGridSquareCreationTest()
\shape default
 Testa la creazione di una casella con valori personalizzati.
\end_layout

\begin_layout Enumerate

\shape italic
validDamageTest()
\shape default
 Verifica che una casella possa ricevere danno e memorizzarlo correttamente.
\end_layout

\begin_layout Enumerate

\shape italic
invalidDamageTest() 
\shape default
Testa il comportamento quando si cerca di impostare un livello di danno negativo o oltre il limite massimo.
\end_layout

\begin_layout Enumerate

\shape italic
isOccupiedTest() 
\shape default
Controlla che si possa impostare una casella come occupata e che il valore venga aggiornato correttamente.
\end_layout

\begin_layout Enumerate

\shape italic
isHitTest()
\shape default
 Controlla che si possa impostare una casella come colpita e che il valore venga aggiornato correttamente.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
GridTest.java 
\series default
Testa il comportamento della classe 
\shape italic
Grid.java
\shape default
,
 che gestisce l’intera griglia del gioco.
\end_layout

\begin_deeper
\begin_layout Enumerate

\shape italic
validShipPositioningTest()
\shape default
 Verifica che una nave possa essere posizionata correttamente in una zona libera della griglia.
\end_layout

\begin_layout Enumerate

\shape italic
outOfGridPositioningTest()
\shape default
 Tenta di posizionare una nave fuori dai limiti della griglia e verifica che venga lanciata un eccezione.
\end_layout

\begin_layout Enumerate

\shape italic
placeOverOccupiedTest()
\shape default
 Verifica che non sia possibile sovrapporre due navi e che quindi venga lanciata una eccezione.
\end_layout

\begin_layout Enumerate

\shape italic
everythingIsSunkTest()
\shape default
 Controlla che la griglia abbia tutte le navi affondate.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
ShipTest.java 
\series default
Testa il comportamento della classe 
\shape italic
Ship.java
\shape default
,
 che rappresenta una nave composta da più caselle.
\end_layout

\begin_deeper
\begin_layout Enumerate

\shape italic
partialDamageTest()
\shape default
 Crea una nave composta da tre caselle,
 alcune con danno parziale e controlla che la nave non venga considerata affondata.
\end_layout

\begin_layout Enumerate

\shape italic
isSunkTest()
\shape default
 Crea una nave con tutte le caselle completamente danneggiate e controlla che il metodo isSunk() restituisca true.
\end_layout

\begin_layout Enumerate

\shape italic
fullDamageSunkTest() 
\shape default
Simula un attacco progressivo:
\end_layout

\begin_deeper
\begin_layout Enumerate
Colpisce la nave più volte fino a farla affondare completamente.
\end_layout

\begin_layout Enumerate
Dopo ogni colpo,
 controlla che isSunk() restituisca false fino al colpo finale.
\end_layout

\begin_layout Enumerate
Dopo il colpo finale,
 isSunk() deve restituire true.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\series bold
BattleTest.java 
\series default
Testa il comportamento della classe 
\shape italic
Battle.java
\shape default
,
 che gestisce l’intera partita.
\end_layout

\begin_deeper
\begin_layout Enumerate

\shape italic
notEndingTurnTest()
\shape default
 Simula un turno in cui il giocatore manca il bersaglio (colpo a vuoto).
 Controlla che:
\end_layout

\begin_deeper
\begin_layout Enumerate
Il turno passi all'avversario.
\end_layout

\begin_layout Enumerate
Il gioco non sia terminato (isGameOver() deve restituire false).
\end_layout

\end_deeper
\begin_layout Enumerate

\shape italic
endingTurnTest()
\shape default
 Simula un colpo che affonda l'ultima nave dell’avversario.
 Controlla che:
\end_layout

\begin_deeper
\begin_layout Enumerate
Il gioco venga dichiarato terminato (isGameOver() restituisce true).
\end_layout

\begin_layout Enumerate
Il vincitore sia il giocatore che ha colpito (getWinner() restituisce il vincitore corretto).
\end_layout

\end_deeper
\begin_layout Enumerate

\shape italic
executeTurnAfterGameOverTest()
\shape default
 Simula il caso in cui un giocatore tenta di sparare dopo la fine della partita e verifica che venga lanciata una eccezione.
\end_layout

\end_deeper
\begin_layout Subsection
METODOLOGIA DI LAVORO
\end_layout

\begin_layout Standard
Lo sviluppo del progetto è stato svolto interamente in autonomia,
 senza attività di gruppo.
 La scelta di lavorare da solo ha richiesto un’organizzazione personale efficace e una pianificazione attenta,
 al fine di gestire in modo equilibrato il tempo dedicato all’analisi,
 alla progettazione,
 allo sviluppo e alla fase di test e rifinitura del codice.
\begin_inset Newline newline
\end_inset

Ho adottato una mia personale metodologia di lavoro ispirata a pratiche agili,
 modellata sulle esigenze del mio tempo disponibile.
 In particolare,
 ho preferito suddividere l’attività settimanale in due momenti distinti:
\end_layout

\begin_layout Itemize
Durante la settimana,
 quando avevo a disposizione blocchi di tempo più brevi (in media un’ora),
 mi sono concentrato sullo sviluppo e test di piccole unità funzionali (classi,
 metodi,
 strategie specifiche),
 lavorando in modo incrementale e isolato.
 Questa fase è stata utile per sperimentare,
 identificare errori in modo tempestivo e mantenere costante il contatto con il progetto.
\end_layout

\begin_layout Itemize
Durante il fine settimana,
 ho dedicato sessioni più estese al refactoring,
 all’integrazione dei moduli sviluppati nei giorni precedenti e alla pulizia del codice,
 consolidando la coerenza architetturale ad esempio applicando pattern come MVC,
 Strategy,
 Factory.
\end_layout

\begin_layout Standard
Nel corso del progetto,
 ho seguito un processo iterativo così strutturato:
\end_layout

\begin_layout Itemize
Analisi del problema e dei requisiti – individuazione delle funzionalità attese e delle entità del dominio.
\end_layout

\begin_layout Itemize
Progettazione modulare e architetturale – separazione chiara dei ruoli,
 uso di interfacce per disaccoppiamento,
 riflessioni sull’applicazione di design pattern.
\end_layout

\begin_layout Itemize
Sviluppo incrementale – realizzazione dei package:
\end_layout

\begin_deeper
\begin_layout Itemize
model.* per la logica di gioco e le entità;
\end_layout

\begin_layout Itemize
view.* per la GUI/TUI e i componenti di output;
\end_layout

\begin_layout Itemize
controller.* per la gestione del flusso di gioco;
\end_layout

\end_deeper
\begin_layout Itemize
Testing e validazione – uso di test JUnit per verificare le funzionalità 
\begin_inset Quotes eld
\end_inset

core
\begin_inset Quotes erd
\end_inset

 fondamentali.
\end_layout

\begin_layout Itemize
Refactoring e documentazione – pulizia del codice,
 miglioramento della leggibilità e commenti,
 stesura della relazione.
\end_layout

\begin_layout Subsection
NOTE DI SVILUPPO
\end_layout

\begin_layout Standard

\series bold
Feature avanzate del linguaggio che sono state utilizzate
\end_layout

\begin_layout Itemize

\shape italic
Uso di lambda expressions
\shape default

\begin_inset Newline newline
\end_inset

Utilizzate in modo puntuale,
 ad esempio nella scrittura di test unitari per la verifica di eccezioni nel test 
\shape italic
GridSquareTest.java
\shape default
.
\begin_inset Newline newline
\end_inset


\begin_inset listings
lstparams "language=Java,basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout
\align left

Exception exception = assertThrows(IllegalArgumentException.class,
 () -> { ...
 });
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\shape italic
Uso di Stream API combinate con lambda expressions
\shape default

\begin_inset Newline newline
\end_inset

Impiego stream() in 
\shape italic
Ship.java
\shape default
 su tutte le caselle che compongono una nave per verificarne l'affondamento completo.
\begin_inset Newline newline
\end_inset


\begin_inset listings
lstparams "language=Java,basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout
\align left

return gridSquares.stream()
\end_layout

\begin_layout Plain Layout
\align left

	.allMatch(gridSquare -> gridSquare.getDamageLevel() 
\end_layout

\begin_layout Plain Layout
\align left

				>= gridSquare.getMaxResistance());
\end_layout

\end_inset

Impiego di stream() in Grid.java per verificare che tutte le navi siano affondate.
\begin_inset Newline newline
\end_inset


\begin_inset listings
lstparams "language=Java,basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout
\align left

return ships.stream().allMatch(ship -> ship.isSunk());
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Sviluppo di algoritmi particolarmente interessanti
\series default

\begin_inset Newline newline
\end_inset

I seguenti algoritmi sono stati trattati in dettaglio nella sezione 2.2 
\begin_inset Quotes eld
\end_inset

Design dettagliato
\begin_inset Quotes erd
\end_inset

 sottosezione 2.2.3,
 si elencano per completezza.
\end_layout

\begin_layout Itemize

\shape italic
Modalità "Hunt and Target" (livello IA medio)
\shape default
:
 implementazione di una strategia dinamica che,
 a seguito di un colpo a segno,
 seleziona le celle adiacenti come target,
 evitando quelle già colpite.
\end_layout

\begin_layout Itemize

\shape italic
Modalità "Pseudo-AI" (livello IA difficile)
\shape default
:
 calcolo di un punteggio euristico per ogni cella della griglia in base alla disposizione e agli spazi disponibili,
 simulando un comportamento intelligente.
 Viene poi stimata una probabilità per guidare la scelta del tipo di proiettile.
\end_layout

\end_body
\end_document
